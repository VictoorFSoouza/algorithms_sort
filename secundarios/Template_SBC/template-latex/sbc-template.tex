\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage[portuguese]{babel}
%\usepackage[brazil]{babel}   
%\usepackage[latin1]{inputenc} 
 %\usepackage[utf8]{inputenc} 
%\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{indentfirst}
\newcommand{\vars}{\texttt}
\newcommand{\func}{\textrm}
\algnewcommand\And{\textbf{and}}
\algnewcommand\To{\textbf{to }}
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}


     
\sloppy

\title{Algoritmos de ordenação - bubble, quick, insertion}

\author{Cleber Soares\inst{1},  Sthefany Oliveira \inst{1}, Victor Souzal\inst{1} }


\address{Faculdade de Computação e engenharia elétrica\\Universidade Federal do Sul e Sudeste do Pará
  (UNIFESSPA)\\
  68505-080 -- Marabá -- PA -- Brasil\\
  \email{\{cleber.soares,sthefany.oliveira,victoor.soouza\}@unifesspa.edu.br}
}

\begin{document} 

\maketitle

\begin{abstract}
  Ordering algorithms are computational methods for organizing and / or ordering a list of numbers or words according to their individualities, they can take care of each case that best suits their needs and then improve certain problems that are related to the retrieval of data in lists, that is, facilitate the search of information. This article presents its implementation, execution and comparative among three sorting algorithms that are: Insertion Sort, Bubble Sort, and Quick Sort. For the purpose of analyzing your results and checking the positives and negatives of each.
\end{abstract}
     
\begin{resumo} 
  Os algoritmos de ordenação são métodos computacionais para organizar e ou ordenar lista de números ou palavras, de acordo com suas individualidades, podem atender cada caso que se adeque melhor a sua necessidade para então melhorar certos problemas que estejam relacionados a recuperação de dados em listas, ou seja, facilitam a busca das informações. Este artigo apresenta a sua implementação, execução e comparativo entre três algoritmos de ordenação que são: Insertion Sort, Bubble Sort, e Quick Sort. Com a finalidade de analisar seus resultados e verificar os pontos positivos e negativos de cada um.
\end{resumo}	


	
\section{Algoritmos}

\subsection{Bubble Sort}

O Bubble Sort é o tipo mais antigo e mais simples usado para ordenações. Ele
funciona comparando cada item da lista com o item do lado dele, e efetua a troca se o
valor na posição que está sendo analisada for maior que o da posição após a dele. O
algoritmo repete este processo até passar por todas as posições da lista. Isto faz com que
os valores maiores “flutuem” para o final da lista, enquanto os valores menores “afundem”
para o início da lista \cite{da2016analise}.
	
	Tal algoritmo usa a estrategia de troca e seu pior caso O(n$^2$) e melhor caso O(n).

	\begin{algorithm}[H]
		\caption{Bubble Sort}
		\begin{algorithmic}[1]
			\Function{BUBBLESORT}{$A, n$}		
				\For{$ i = 0 $ \To $ i < (n - 1) $ }
					\For{$ j = 0 $ \To $ j < (n - i - 1) $ }
						\If{$A[j] > A[j + 1] $}
							\State $temp = A[j]$		
							\State $A[j] = A[j+1]$			
							\State $A[j+1] = temp$				
						\EndIf
					\EndFor						
				\EndFor				
			\EndFunction
			
			
		\end{algorithmic}
	\end{algorithm}	
	
\subsection{Insertion Sort}
	O algoritmo consiste em uma ordenação percorrendo o vetor da esquerda para direita, e conforme avanca, vai ordenando os valores da sua esquerda.  Possui um melhor caso em forma ordenada com complexidade de O(n) e os casos medio e pior com complexidade de O(n2) \cite{santoscomparacc}.


	\begin{algorithm}[H]
		\caption{Insertion Sort}
		\begin{algorithmic}[1]

			\Function{INSERTIONSORT}{$A, p, r$}		
				\For{$j = 2$ \To $ n $ }
					\State $temp = A[j]$	
					\State $i = j - 1$		
										
					\While{$ ( i > 0 ) $ \And $ ( A[i] > temp ) $} 
						\State$A[i + 1] = A[i]$
						\State$i = i - 1 $
					\EndWhile
					\State$A[i + 1] = temp$				
				\EndFor
				
				
			\EndFunction
			
			
		\end{algorithmic}
	\end{algorithm}




\subsection{Quick Sort}

	Em primeiro momento iremos falar sobre a função partition que é de extrema importância para o Quick Sort. 
	
	A  função partition elege  um  dos  elementos  da  sequência  como  elemento
pivô.   Após  essa eleição, cada elemento da sequência é comparado com o pivô e, se for menor que o pivô, deverá ficar à esquerda desse,  se for maior que o pivô,  deverá ficar à direita.   Ao final dessa etapa,  o elemento pivô fica na sua posição final da seqüência ordenada \cite{prado2005analise}. 
	
	Essa função irá determinar o nivel de balanciamento do quick sort que terá grande importância em seu desempenho.
	
	
	
	\begin{algorithm}[H]
		\caption{Partition}
		\begin{algorithmic}[1]	
			\Function{partition}{$A, p, r$}		
				\State $x = A[r] $	
				\State $i = p - 1$
				\For{$j = p$  \To $r - 1$ }
					\If{$A[j] <= x $}
						\State$temp = A[i]$
						\State$A[i] = A[j]$
						\State$A[j] = temp$
					\EndIf
				\EndFor
				\State$temp = A[i + 1]$
				\State$A[i + 1] = A[r]$
				\State$A[r] = temp$
				\Return $i + 1$
			\EndFunction
			\end{algorithmic}
	\end{algorithm}
	
	
	
	O Quicksort é um algoritmo do tipo dividir para conquistar para ordenação cujo tempo de
execução  no  pior  caso  é O(n$^2$) sobre  uma  seqüência  de  entrada  de n números pior caso do Quicksort ocorre quando todos os particionamentos de todos os níveis de recursão ocorrem da pior maneira possível, ou seja, o elemento escolhido como pivô pela função particiona for sempre maior ou o menor elemento da seqüência \cite{prado2005analise}.

O melhor caso do Quicksort ocorre quando todos os particionamentos em todos os níveis de recursão forem ótimos, ou seja, quando toda vez que a função particiona for chamada, ela divida a seqüência exatamente ao meio (log$_2$n) \cite{prado2005analise}.
\begin{algorithm}[H]
		\caption{Quick Sort}
		\begin{algorithmic}[1]	
			\Function{QUICKSORT}{$A, p, r$}		
				\If{$p < r $}
					\State$q = PARTITION(A, p, r)$
					\State$QUICKSORT(A, p, q - 1 )$
					\State$QUICKSORT(A, q +1, r)$
				\EndIf			
			\EndFunction
			
			
		\end{algorithmic}
	\end{algorithm}
	
	











\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
\grid
\grid
\grid
